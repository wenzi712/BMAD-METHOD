# 棕地开发完全指南

## 关键提示

无论您计划如何处理想要使用智能体编码的现有项目，为智能体生成上下文工件都是最重要的。

如果使用Claude Code，建议使用document-project任务与架构师一起系统地为您的代码库生成重要的关键工件。

您也可以选择利用Gemini等网络智能体为您的代码库生成上下文信息和理解。如果代码库已经在GitHub上，您可以在Gemini中提供项目URL，并使用智能体团队（如fullstack团队或特定的架构师智能体）帮助分析或记录项目。

如果您的项目太大，您还可以将代码库扁平化 - 这可以使其更容易上传或与某些工具一起使用。您可以在[扁平化工具指南](./flattener_ZH.md)中了解更多关于这个可选工具的信息。

## 什么是棕地开发？

棕地开发是指在现有软件项目中添加功能、修复错误或进行现代化改造。与绿地（新）项目不同，棕地工作需要理解现有代码、尊重约束条件，并确保新的更改能够无缝集成而不会破坏现有功能。

## 何时为棕地使用BMad

- 向现有应用程序添加重要的新功能
- 现代化改造遗留代码库
- 集成新技术或服务
- 重构复杂系统
- 修复需要架构理解的错误
- 记录未文档化的系统

## 何时不使用棕地流程

如果您刚刚使用BMad完成了MVP，并且想继续进行MVP后的开发，只需与PM交谈，要求它与您一起创建一个新的史诗（epic）添加到PRD中，拆分史诗，与架构师一起更新架构文档，然后从那里继续。

## 完整的棕地工作流程

从网页选项开始（可能节省一些成本，但体验可能更令人沮丧）：

1. **按照[<ins>用户指南 - 安装</ins>](user-guide_ZH.md#installation)步骤在网络上设置您的智能体。**
2. **生成整个代码库的'扁平化'单文件**，运行：`npx bmad-method flatten`

在具有大上下文和良好模型的IDE中开始（这个过程中使用高质量模型非常重要，以获得最佳效果）：

1. 在Claude Code或类似的IDE中，选择架构师智能体，然后使用*document-project任务。您需要确保验证并指导智能体为LLM生成最佳的文档来理解您的代码库，而不包含任何误导性或不必要的信息。

### 选择您的方法

#### 方法A：先PRD（推荐用于添加非常大且复杂的新功能、单个或多个史诗或大规模更改）

**最适合**：大型代码库、单体仓库，或者当您确切知道要构建什么时

1. **先创建PRD**来定义需求
2. **仅记录相关区域**，基于PRD需求
3. **更高效** - 避免记录未使用的代码

#### 方法B：先文档（适合较小的项目）

**最适合**：较小的代码库、未知系统或探索性更改

1. **首先记录整个系统**
2. **创建PRD**，具有完整上下文
3. **更全面** - 捕获所有内容

### 方法A：先PRD工作流程（推荐）

#### 第一阶段：先定义需求

**在Gemini网络版中（上传您的flattened-codebase.xml）：**

```bash
@pm
*create-brownfield-prd
```

PM将：

- **询问您的增强**需求
- **探索代码库**以了解当前状态
- **识别需要文档的受影响区域**
- **创建聚焦的PRD**，明确范围

**关键优势**：PRD会识别您的单体仓库/大型代码库中哪些部分实际上需要文档！

#### 第二阶段：聚焦文档

**仍然在Gemini网络版中，现在有PRD上下文：**

```bash
@architect
*document-project
```

架构师将：

- **询问您的重点**（如果未提供PRD）
- **提供选项**：创建PRD、提供需求或描述增强
- **参考PRD/描述**以了解范围
- **专注于PRD或描述中确定的相关模块**
- **跳过不相关区域**，保持文档简洁
- **为所有环境生成一个架构文档**

架构师创建：

- **一份全面的架构文档**，遵循全栈架构模板
- **在单个文件中涵盖所有系统方面**
- **易于复制和保存**为`docs/architecture.md`
- **如果需要，以后可以在IDE中分片**

例如，如果您说"向用户服务添加支付处理"：

- 仅记录：用户服务、API端点、数据库模式、支付集成
- 创建聚焦的源代码树，仅显示与支付相关的代码路径
- 跳过：管理面板、报告模块、不相关的微服务

### 方法B：先文档工作流程

#### 第一阶段：记录现有系统

**最佳方法 - 具有1M+上下文的Gemini网络版：**

1. **前往Gemini网络版**（gemini.google.com）
2. **上传您的项目**：
   - **选项A**：直接粘贴您的GitHub仓库URL
   - **选项B**：上传您的flattened-codebase.xml文件
3. **加载架构师智能体**：上传`dist/agents/architect.txt`
4. **运行文档生成**：输入`*document-project`

架构师将生成全面的文档，涵盖所有内容。

#### 第二阶段：计划您的增强

##### 选项A：完整棕地工作流程（推荐用于重大更改）

**1. 创建棕地PRD**：

```bash
@pm
*create-brownfield-prd
```

PM智能体将：

- **分析第一阶段的现有文档**
- **向您请求具体的增强细节**
- **评估复杂性**并推荐方法
- **为增强创建史诗/故事结构**
- **识别风险和集成点**

**PM智能体如何获取项目上下文**：

- 在Gemini网络版中：已经从第一阶段文档中获得了完整的项目上下文
- 在IDE中：会询问"请提供现有项目文档的路径"

**您将遇到的关键提示**：

- "您想添加什么特定的增强或功能？"
- "是否有任何需要集成的现有系统或API？"
- "我们必须尊重哪些关键约束条件？"
- "您的时间表和团队规模是多少？"

**2. 创建棕地架构**：

```bash
@architect
*create-brownfield-architecture
```

架构师将：

- **审查棕地PRD**
- **设计集成策略**
- **如果需要，规划迁移方法**
- **识别技术风险**
- **定义兼容性要求**

##### 选项B：快速增强（用于聚焦更改）

**对于没有完整PRD的单个史诗**：

```bash
@pm
*create-brownfield-epic
```

当以下情况使用：

- 增强定义明确且隔离
- 现有文档全面
- 更改不影响多个系统
- 您需要快速周转

**对于单个故事**：

```bash
@pm
*create-brownfield-story
```

当以下情况使用：

- 错误修复或小功能
- 非常孤立的更改
- 无架构影响
- 明确的实现路径

### 第三阶段：验证计划工件

```bash
@po
*execute-checklist-po
```

PO确保：

- 与现有系统的兼容性
- 没有计划的破坏性更改
- 有风险缓解策略
- 明确的集成方法

### 第四阶段：保存并分片文档

1. 保存您的PRD和架构为：
   docs/prd.md
   docs/architecture.md
   （注意：如果管理多个版本，可以选择在前面加上'brownfield-'前缀）
2. 分片您的文档：
   在您的IDE中

   ```bash
   @po
   shard docs/prd.md
   ```

   ```bash
   @po
   shard docs/architecture.md
   ```

### 第五阶段：过渡到开发

**遵循[<ins>增强IDE开发工作流程</ins>](enhanced-ide-development-workflow_ZH.md)**

## 棕地最佳实践

### 1. 始终先文档化

即使您认为您了解代码库：

- 运行`document-project`以捕获当前状态
- AI智能体需要这个上下文
- 发现未文档化的模式

### 2. 尊重现有模式

棕地模板专门寻找：

- 当前的编码约定
- 现有的架构模式
- 技术约束
- 团队偏好

### 3. 计划渐进式推出

棕地更改应：

- 支持功能标志
- 计划回滚策略
- 包含迁移脚本
- 保持向后兼容性

### 4. 彻底测试集成

#### 为什么测试架构师对棕地至关重要

在棕地项目中，测试架构师（Quinn）成为您防止破坏现有功能的安全网。与绿地项目不同，棕地需要仔细验证新更改不会破坏已经工作的功能。

#### 棕地特定测试挑战

测试架构师解决棕地项目中的独特复杂性：

| **挑战**               | **测试架构师如何提供帮助**                      | **命令**         |
| --------------------------- | ------------------------------------------------- | ------------------- |
| **回归风险**        | 识别可能会破坏的现有功能    | `*risk`             |
| **遗留依赖**     | 映射集成点和隐藏依赖   | `*trace`            |
| **性能下降** | 验证现有流程没有变慢           | `*nfr`              |
| **覆盖缺口**           | 找到新更改触及的未测试遗留代码 | `*design`           |
| **破坏性更改**        | 检测API/合约违规                   | `*review`           |
| **迁移安全**        | 验证数据转换和回滚计划 | `*risk` + `*review` |

#### 棕地测试架构师完整工作流程

##### 阶段1：开发前（风险与策略）

**棕地项目关键步骤 - 首先运行这些命令：**

```bash
# 1. 风险评估（故事创建后立即运行）
@qa *risk {brownfield-story}
# 识别：遗留依赖、破坏性更改、集成点
# 输出：docs/qa/assessments/{epic}.{story}-risk-{YYYYMMDD}.md
# 棕地重点：
#   - 回归概率评分
#   - 受影响的下游系统
#   - 数据迁移风险
#   - 回滚复杂性

# 2. 测试设计（风险评估后）
@qa *design {brownfield-story}
# 创建：回归测试策略 + 新功能测试
# 输出：docs/qa/assessments/{epic}.{story}-test-design-{YYYYMMDD}.md
# 棕地重点：
#   - 需要回归测试的现有功能
#   - 集成测试要求
#   - 要维持的性能基准
#   - 功能标志测试场景
```

##### 阶段2：开发期间（持续验证）

**编码时监控集成健康状况：**

```bash
# 3. 需求跟踪（开发中期检查点）
@qa *trace {brownfield-story}
# 映射：新需求 + 现有功能保留
# 输出：docs/qa/assessments/{epic}.{story}-trace-{YYYYMMDD}.md
# 棕地重点：
#   - 必须仍然工作的现有功能
#   - 新旧功能交互
#   - API合约保留
#   - 缺失的回归测试覆盖

# 4. NFR验证（考虑"完成"之前）
@qa *nfr {brownfield-story}
# 验证：性能、安全性、可靠性不变
# 输出：docs/qa/assessments/{epic}.{story}-nfr-{YYYYMMDD}.md
# 棕地重点：
#   - 性能回归检测
#   - 集成的安全影响
#   - 向后兼容性验证
#   - 对遗留组件的负载/压力
```

##### 阶段3：代码审查（深度集成分析）

**全面的棕地审查：**

```bash
# 5. 全面审查（开发完成时）
@qa *review {brownfield-story}
# 执行：深度分析 + 主动重构
# 输出：
#   - 故事文件中的QA结果
#   - 门控文件：docs/qa/gates/{epic}.{story}-{slug}.yml
```

审查专门分析：

- **API破坏性更改**：验证所有现有合约是否维持
- **数据迁移安全**：检查转换逻辑和回滚程序
- **性能回归**：与基准指标比较
- **集成点**：验证与遗留代码的所有接触点
- **功能标志逻辑**：确保适当的切换行为
- **依赖影响**：映射受影响的下游系统

##### 阶段4：审查后（门控更新）

```bash
# 6. 门控状态更新（解决问题后）
@qa *gate {brownfield-story}
# 更新：修复后的质量门控决策
# 输出：docs/qa/gates/{epic}.{story}-{slug}.yml
# 棕地考虑因素：
#   - 可能会放弃某些遗留代码问题
#   - 记录技术债务接受情况
#   - 跟踪迁移进度
```

#### 棕地特定风险评分

测试架构师对棕地使用增强的风险评分：

| **风险类别**      | **棕地因素**                     | **对门控的影响**  |
| ---------------------- | ------------------------------------------ | ------------------- |
| **回归风险**    | 集成点数量 × 代码年龄 | 分数 ≥9 = 失败     |
| **数据风险**          | 迁移复杂性 × 数据量         | 分数 ≥6 = 需关注 |
| **性能风险**   | 当前负载 × 增加的复杂性            | 分数 ≥6 = 需关注 |
| **兼容性风险** | API消费者 × 合约更改           | 分数 ≥9 = 失败     |

#### 棕地测试标准

Quinn为棕地执行额外的标准：

- **回归测试覆盖**：每个触及的遗留模块都需要测试
- **性能基准**：必须维持或改进当前指标
- **回滚程序**：每项更改都需要回滚计划
- **功能标志**：所有风险更改都有开关控制
- **集成测试**：覆盖所有遗留接触点
- **合约测试**：验证API兼容性
- **数据验证**：迁移正确性检查

#### 快速参考：棕地测试命令

| **场景**                      | **要运行的命令**                                  | **顺序**  | **为什么关键**              |
| --------------------------------- | ---------------------------------------------------- | ---------- | ----------------------------- |
| **向遗留代码添加功能** | `*risk` → `*design` → `*trace` → `*review`           | 顺序执行 | 首先映射所有依赖项    |
| **API修改**              | `*risk` → `*design` → `*nfr` → `*review`             | 顺序执行 | 防止破坏消费者    |
| **性能关键更改**   | `*nfr` 尽早并经常运行 → `*review`                   | 持续进行 | 立即捕获性能下降 |
| **数据迁移**                | `*risk` → `*design` → `*trace` → `*review` → `*gate` | 完整周期 | 确保数据完整性         |
| **复杂系统中的错误修复**     | `*risk` → `*trace` → `*review`                       | 重点关注    | 防止副作用          |

#### 与棕地场景集成

**场景特定指导：**

1. **遗留代码现代化**
   - 从`*risk`开始映射所有依赖
   - 使用`*design`规划绞杀者模式方法
   - 频繁运行`*trace`确保没有东西破坏
   - `*review`重点关注渐进式迁移

2. **向单体添加功能**
   - `*risk`识别集成复杂性
   - `*design`规划隔离策略
   - `*nfr`监控性能影响
   - `*review`验证单体没有退化

3. **微服务提取**
   - `*risk`映射服务边界
   - `*trace`确保功能保留
   - `*nfr`验证网络开销可接受
   - `*gate`记录接受的权衡

4. **数据库模式更改**
   - `*risk`评估迁移复杂性
   - `*design`规划向后兼容方法
   - `*trace`映射所有受影响的查询
   - `*review`验证迁移安全

### 5. 沟通变更

记录：

- 什么改变了以及为什么
- 迁移说明
- 引入的新模式
- 弃用通知

## 常见棕地场景

### 场景1：添加新功能

1. 记录现有系统
2. 创建专注于集成的棕地PRD
3. **测试架构师早期参与**：
   - 对草稿故事运行`@qa *risk`以识别集成风险
   - 使用`@qa *design`规划回归测试策略
4. 架构强调兼容性
5. 故事包括集成任务和测试要求
6. **开发期间**：
   - 开发人员运行`@qa *trace`验证覆盖
   - 使用`@qa *nfr`监控性能影响
7. **审查阶段**：`@qa *review`验证集成安全

### 场景2：现代化遗留代码

1. 广泛的文档阶段
2. PRD包含迁移策略
3. **测试架构师策略规划**：
   - `@qa *risk`评估现代化复杂性
   - `@qa *design`规划并行测试方法
4. 架构规划渐进式过渡（绞杀者模式）
5. 故事遵循增量现代化，包括：
   - 未触及的遗留代码的回归测试
   - 新旧边界的集成测试
   - 每个阶段的性能基准
6. **持续验证**：每个增量后运行`@qa *trace`
7. **门控管理**：使用`@qa *gate`跟踪技术债务接受情况

### 场景3：复杂系统中的错误修复

1. 记录相关子系统
2. 使用`create-brownfield-story`进行聚焦修复
3. **测试架构师风险评估**：运行`@qa *risk`识别副作用潜力
4. 包含来自`@qa *design`输出的回归测试要求
5. **修复期间**：使用`@qa *trace`映射受影响功能
6. **提交前**：运行`@qa *review`进行全面验证
7. 测试架构师使用以下方法验证没有副作用：
   - 副作用分析的风险分析（概率×影响评分）
   - 跟踪矩阵确保修复不会破坏相关功能
   - NFR评估验证性能/安全性不变
   - 门控决策记录修复安全性

### 场景4：API集成

1. 记录现有API模式
2. PRD定义集成要求
3. **测试架构师合约分析**：
   - `@qa *risk`识别破坏性变更潜力
   - `@qa *design`创建合约测试策略
4. 架构确保一致模式
5. **API测试重点**：
   - 向后兼容性的合约测试
   - 新端点的集成测试
   - 增加负载的性能测试
6. 故事包括API文档更新
7. **验证检查点**：
   - `@qa *trace`映射所有API消费者
   - `@qa *nfr`验证响应时间
   - `@qa *review`确保无破坏性更改
8. **门控决策**：记录任何接受的破坏性更改及其迁移路径

## 故障排除

### "AI不理解我的代码库"

**解决方案**：使用更具体的关键文件路径重新运行`document-project`

### "生成的计划不符合我们的模式"

**解决方案**：在规划阶段之前，使用您特定的约定更新生成的文档

### "小型更改有太多样板"

**解决方案**：使用`create-brownfield-story`代替完整工作流程

### "集成点不明确"

**解决方案**：在PRD创建期间提供更多上下文，特别强调集成系统

## 快速参考

### 棕地特定命令

```bash
# 记录现有项目
@architect *document-project

# 创建增强PRD
@pm *create-brownfield-prd

# 创建具有集成重点的架构
@architect *create-brownfield-architecture

# 快速史诗创建
@pm *create-brownfield-epic

# 单个故事创建
@pm *create-brownfield-story
```

### 棕地测试架构师命令

注意：下面显示的是简写形式。完整命令：`*risk-profile`、`*test-design`、`*nfr-assess`、`*trace-requirements`

```bash
# 开发前（规划）
@qa *risk {story}     # 评估回归和集成风险
@qa *design {story}   # 规划回归 + 新功能测试

# 开发期间（验证）
@qa *trace {story}    # 验证新旧代码覆盖
@qa *nfr {story}      # 检查性能下降

# 开发后（审查）
@qa *review {story}   # 深度集成分析
@qa *gate {story}     # 更新质量决策
```

### 决策树

```text
您是否有大型代码库或单体仓库？
├─ 是 → 先PRD方法
│   └─ 创建PRD → 仅记录受影响区域
└─ 否 → 您对代码库是否熟悉？
    ├─ 是 → 先PRD方法
    └─ 否 → 先文档方法

这是影响多个系统的重大增强吗？
├─ 是 → 完整棕地工作流程
│   └─ 始终首先运行测试架构师 *risk + *design
└─ 否 → 这不仅仅是简单的错误修复吗？
    ├─ 是 → *create-brownfield-epic
    │   └─ 运行测试架构师 *risk 检查集成点
    └─ 否 → *create-brownfield-story
        └─ 如果触及关键路径，仍然运行 *risk

更改是否触及遗留代码？
├─ 是 → 测试架构师是强制性的
│   ├─ *risk → 识别回归潜力
│   ├─ *design → 规划测试覆盖
│   └─ *review → 验证无破坏
└─ 否 → 测试架构师是推荐的
    └─ *review → 确保质量标准
```

## 结论

使用BMad方法进行棕地开发在修改现有系统时提供了结构和安全性。测试架构师成为您的关键安全网，使用风险评估、回归测试和持续验证来确保新更改不会破坏现有功能。

**棕地成功公式：**

1. **先文档化** - 了解现有内容
2. **早期评估风险** - 在编码前使用测试架构师的`*risk`
3. **规划测试策略** - 设计回归 + 新功能测试
4. **持续验证** - 在开发期间检查集成健康状况
5. **全面审查** - 在提交前进行深度分析
6. **果断门控** - 记录质量决策

记住：**在棕地开发中，测试架构师不是可选的 - 它是您防止破坏生产环境的保险单。**